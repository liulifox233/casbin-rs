searchState.loadedDescShard("casbin", 0, "Enforcer is the main interface for authorization …\nContains the error value\nContains the success value\nEnforce decides whether a “subject” can access a “…\nEnforce decides whether a “subject” can access a “…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdapterError error represents any type of errors in adapter…\nGeneral casbin error\nModelError represents any type of errors in model …\nPolicyError represents any type of errors in policy\nRBAC error represents any type of errors in RBAC role …\nRequestError represents any type of errors in coming …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCompiled AST (abstract syntax tree) of a Rhai script.\nVariable-sized array of <code>Dynamic</code> values.\nAssignment to an a constant variable. Wrapped value is the …\nAssignment to an inappropriate LHS (left-hand-side) …\nError in the script text. Wrapped value is the lex error.\nVariable-sized array of <code>u8</code> values (byte array).\nTrait to build the API of a custom type for use with an …\nMacro to implement the [<code>CustomType</code>][rhai::CustomType] …\nA map definition has duplicated property names. Wrapped …\nA <code>switch</code> case is duplicated.\nA variable name is duplicated. Wrapped value is the …\nDynamic type containing any value.\nRhai main scripting engine.\nArithmetic error encountered. Wrapped value is the error …\nArray access out-of-bounds. Wrapped values are the current …\nAssignment to a constant variable. Wrapped value is the …\nBit-field indexing out-of-bounds. Wrapped values are the …\nError encountered for a custom syntax. Wrapped values are …\nData race detected when accessing a variable. Wrapped …\nData value over maximum size limit. Wrapped value is the …\nInappropriate property access. Wrapped value is the …\nThe <code>for</code> statement encounters a type that is not iterable.\nForbidden variable name. Wrapped value is the variable …\nCall to an unknown function. Wrapped value is the function …\nAn error has occurred inside a called function. Wrapped …\nAn error has occurred while loading a module. Wrapped …\nAccess of an invalid index. Wrapped value is the index …\nTrying to index into a type that has no indexer function …\nData is not of the required type. Wrapped values are the …\nReturned type is not the same as the required output type. …\nUsage of an unknown module. Wrapped value is the module …\nCalling a non-pure method on a constant.  Wrapped value is …\nSyntax error.\nAccess of an unknown object map property. Wrapped value is …\nRun-time error encountered. Wrapped value is the error …\nCall stack over maximum limit.\nString indexing out-of-bounds. Wrapped values are the …\nSystem error. Wrapped values are the error message and the …\nThe script is prematurely terminated. Wrapped value is the …\nModules over maximum limit.\nNumber of operations over maximum limit.\nNumber of variables over maximum limit.\nAccess to <code>this</code> that is not bound.\nShadowing of an existing variable disallowed. Wrapped …\nAccess of an unknown variable. Wrapped value is the …\nEvaluation result.\nContext of a script evaluation process.\nNot an error: Value returned from a script via the <code>exit</code> …\nMissing an expression. Wrapped value is the expression …\nExpression exceeding the maximum levels of complexity.\nAn expression sub-tree in an <code>AST</code>.\nA <code>Dynamic</code> containing a <code>false</code>.\nStandard debug-print function.\nStandard pretty-print function.\nA type representing the access mode of a function.\nDefining a function with a name that conflicts with an …\nA function definition has duplicated parameters. Wrapped …\nA function definition is missing the body. Wrapped value …\nMissing a function name after the <code>fn</code> keyword.\nA function definition is missing the parameters list. …\nA type representing the namespace of a function.\nA general function pointer, which may carry additional …\nForbidden variable name.  Wrapped value is the variable …\nTrait that parses arguments to a function call.\nType for fine-tuned module function registration.\nExpose to global namespace.\nA <code>Dynamic</code> containing the integer 100.\nThe system integer type. It is defined as <code>i32</code> since the …\nThe system immutable string type.\nBad symbol encountered.\nA measurement of a monotonically nondecreasing clock. …\nModule namespace only.\nError encountered when tokenizing the script text.\nLiteral exceeding the maximum size. Wrapped values are the …\nA reader-writer lock\nBreaking out of loops - not an error if within a loop. The …\nBreak statement not inside a loop.\nA <code>Dynamic</code> containing the integer 1,000,000.\nAn expression in function call arguments <code>()</code> has syntax …\nA capturing  has syntax error. Wrapped value is the error …\nAn character literal is in an invalid format.\nAn string/character/numeric escape sequence is in an …\nAn identifier is in an invalid format.\nAn expression in an <code>in</code> expression has syntax error. …\nAn expression in indexing brackets <code>[]</code> has syntax error. …\nAn numeric literal is in an invalid format.\nA dictionary of <code>Dynamic</code> values with string keys.\nAn expression is of the wrong type. Wrapped values are the …\nExpecting a particular symbol but not finding one. Wrapped …\nExpecting a particular token but not finding one. Wrapped …\nA module which may contain variables, sub-modules, …\nAn imported module is not found.\nA <code>Dynamic</code> containing the integer -1.\nA <code>Dynamic</code> containing the integer -2.\nA <code>Position</code> representing no position.\nContext of a native Rust function call.\nA <code>Dynamic</code> containing the integer 1.\nStandard containment testing function.\nStandard equality comparison operator.\nError when parsing a script.\nError encountered when parsing a script.\nA location (line number + character position) in the input …\nPrivate function.\nMissing a property name for custom types and maps.\nPublic function.\nAn identifier is a reserved symbol.\nNot an error: Value returned from a script via the <code>return</code> …\nTrait to register custom Rust functions.\nRuntime error occurred.\nA <code>Position</code> representing the first position.\nType containing information about the current scope. …\nA thread-safe reference-counting pointer. ‘Arc’ stands …\nAn identifier or string literal is longer than the maximum …\nA <code>Dynamic</code> containing the integer 10.\nA <code>Dynamic</code> containing the integer 1,000.\nA <code>Dynamic</code> containing the integer 3.\nA <code>Dynamic</code> containing a <code>true</code>.\nA <code>Dynamic</code> containing the integer 2.\nNumber of scripted functions over maximum limit.\nBuilder to build the API of a custom type for use with an …\nA <code>Dynamic</code> containing a <code>()</code>.\nThe script ends prematurely.\nAn unexpected symbol is encountered.\nAn unknown operator is encountered. Wrapped value is the …\nA string literal is not terminated before a new-line or …\nInformation on a variable declaration.\nA variable is already defined.\nMissing a variable name after the <code>let</code>, <code>const</code>, <code>for</code> or <code>catch</code> …\nA variable is not found.\nDefining a doc-comment in an appropriate place (e.g. not …\nExport statement not at global level.\nDefining a function <code>fn</code> in an appropriate place (e.g. …\nThe case condition of a <code>switch</code> statement is not …\nThe default case of a <code>switch</code> statement is in an …\nA numeric case of a <code>switch</code> statement is in an appropriate …\nA <code>Dynamic</code> containing the integer zero.\nPanics\nAdd a new curried argument.\nReturns a reference to the underlying allocator.\nCast the <code>Dynamic</code> as a <code>bool</code>.\nCast the <code>Dynamic</code> as a <code>char</code>.\nConvert the <code>Dynamic</code> into an <code>ImmutableString</code> and return it. …\nCast the <code>Dynamic</code> as the system integer type <code>INT</code>.\nProvides a raw pointer to the data.\nGet the string slice.\nConvert the <code>Dynamic</code> into a <code>String</code> and return it. If there …\nCast the <code>Dynamic</code> as a unit <code>()</code>.\nConverts to <code>Arc&lt;[T]&gt;</code>.\nConverts to <code>Arc&lt;T&gt;</code>.\nBuilds the custom type for use with the <code>Engine</code>.\nScan through all the sub-modules in the <code>Module</code> and build a …\nCall the function pointer with curried arguments (if any). …\nCall the function pointer with curried arguments (if any). …\nCall a function inside the call context with the provided …\nCall a function inside the call context.\nCall a function (native Rust or scripted) inside the call …\nThe current nesting level of function calls.\nCurrent nesting level of function calls.\nCall a registered native Rust function inside the call …\nCall a registered native Rust function inside the call …\nCall the function pointer with curried arguments (if any). …\nCall the function pointer with curried arguments (if any). …\nConvert the <code>Dynamic</code> value into a specific type.\nReturns <code>Some(t)</code> where <code>t</code> is the time <code>self + duration</code> if <code>t</code> …\nReturns the amount of time elapsed from another instant to …\nReturns <code>Some(t)</code> where <code>t</code> is the time <code>self - duration</code> if <code>t</code> …\nClear the <code>Module</code>.\nEmpty the <code>Scope</code>.\nClear the ID of the <code>Module</code>.\nClear the poisoned state from a lock.\nRemove the position information from this error.\nClear the source.\nClear all statements in the <code>AST</code>, leaving only function …\nClone the <code>Dynamic</code> value.\nMakes a clone of the <code>Arc</code> pointer.\nClone the <code>Dynamic</code> value and convert it into a specific …\nClone the <code>AST</code>’s script statements into a new <code>AST</code>. No …\nClone the <code>Scope</code>, keeping only the last instances of each …\nComparison for two <code>Arc</code>s.\nCombine one <code>AST</code> with another.  The second <code>AST</code> is consumed.\nCombine another <code>Module</code> into this <code>Module</code>. The other <code>Module</code> …\nCombine another <code>Module</code> into this <code>Module</code>. The other <code>Module</code> …\nMacro to combine a <em>plugin module</em> into an existing module.\nConfiguration for Rhai.\nDoes the <code>Scope</code> contain the entry?\nDoes the particular Rust function exist in the <code>Module</code>?\nDoes the <code>Module</code> contain indexed functions that have been …\nDoes a type iterator exist in the module?\nDoes the particular namespace-qualified function exist in …\nDoes a type iterator exist in the entire module tree?\nDoes a sub-module exist in the <code>Module</code>?\nDoes a variable exist in the <code>Module</code>?\nGet the number of variables, functions and type iterators …\nGet the curried arguments.\nDecrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nDecrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nRecursively scan for <code>Dynamic</code> values within this <code>Dynamic</code> …\nMacro that makes it easy to define a <em>package</em> (which is …\nCreates a new <code>Arc&lt;T&gt;</code>, with the <code>Default</code> value for <code>T</code>.\nCreates an empty <code>[T]</code> inside an Arc\nCreates an empty CStr inside an Arc\nCreates an empty str inside an Arc\nCreates a new <code>RwLock&lt;T&gt;</code>, with the <code>Default</code> value for T.\nAttempt to downcast the <code>Arc&lt;dyn Any + Send + Sync&gt;</code> to a …\nDowncasts the <code>Arc&lt;dyn Any + Send + Sync&gt;</code> to a concrete …\nCreates a new <code>Weak</code> pointer to this allocation.\nDrops the <code>Arc</code>.\nReturns the amount of time elapsed from another instant to …\nReturns the amount of time elapsed since this instant.\nCreate an empty <code>AST</code>.\nThe current <code>Engine</code>.\nThe current <code>Engine</code>.\nEquality for two <code>Arc</code>s.\nGet the type of this parse error.\nEvaluate a string as a script, returning the result value …\nEvaluate an expression tree within this evaluation context.\nEvaluate an expression tree within this evaluation context.\nEvaluate a script file, returning the result value or an …\nEvaluate this expression tree within an evaluation context.\nEvaluate this expression tree within an evaluation context.\nAttribute, when put on a Rust function, turns it into a …\nAttribute, when put on a Rust module, turns it into a …\nMacro to generate a Rhai <code>Module</code> from a <em>plugin module</em> …\nMacro to automatically expose a Rust function, type-def or …\nPolyfill this <code>Module</code> with another <code>Module</code>. Only items not …\nFlatten the <code>Dynamic</code>.\nFlatten the <code>Dynamic</code> and clone it.\nName of the function called.\nGet the name of the function.\nReturn the JSON representation of an object map.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>Dynamic</code> from any type.  A <code>Dynamic</code> value is simply …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a <code>&amp;CStr</code> into a <code>Arc&lt;CStr&gt;</code>, by copying the contents …\nConverts a <code>[T; N]</code> into an <code>Arc&lt;[T]&gt;</code>.\nConverts a <code>T</code> into an <code>Arc&lt;T&gt;</code>\nConverts a <code>PathBuf</code> into an Arc&lt;Path&gt; by moving the <code>PathBuf</code> …\nAllocate a reference-counted <code>str</code> and copy <code>v</code> into it.\nCreate an atomically reference-counted pointer from a …\nMove a boxed object to a new, reference-counted allocation.\nCopies the string into a newly allocated Arc&lt;OsStr&gt;.\nConverts a <code>CString</code> into an Arc&lt;CStr&gt; by moving the <code>CString</code> …\nReturns the argument unchanged.\nConverts an atomically reference-counted string slice into …\nAllocate a reference-counted slice and move <code>v</code>’s items …\nAllocate a reference-counted <code>str</code> and copy <code>v</code> into it.\nConverts a <code>Path</code> into an <code>Arc</code> by copying the <code>Path</code> data into …\nAllocate a reference-counted slice and fill it by cloning <code>v</code>…\nConverts an <code>OsString</code> into an Arc&lt;OsStr&gt; by moving the …\nReturns the argument unchanged.\nCreates a new instance of an <code>RwLock&lt;T&gt;</code> which is unlocked. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>Dynamic</code> from an <code>Array</code>.\nCreate a <code>Dynamic</code> from a <code>Blob</code>.\nCreate a new <code>Dynamic</code> from a <code>bool</code>.\nCreate a new <code>Dynamic</code> from a <code>char</code>.\nCreate a new <code>Dynamic</code> from an <code>INT</code>.\nTakes each element in the <code>Iterator</code> and collects it into an …\nCreate a <code>Dynamic</code> from a <code>Map</code>.\nConstructs an <code>Arc&lt;T&gt;</code> from a raw pointer.\nConstructs an <code>Arc&lt;T, A&gt;</code> from a raw pointer.\nCreate a new <code>Dynamic</code> from an <code>Instant</code>.\n‘Greater than or equal to’ comparison for two <code>Arc</code>s.\nGet a reference to an entry in the <code>Scope</code>.\nGet the display name of a registered custom type.\nGet the display name of a registered custom type.\nGet the display name of a registered custom type.\nGet the value of this expression if it is a literal …\nReturns a mutable reference into the given <code>Arc</code>, if there …\nReturns a mutable reference to the underlying data.\nReturn a mutable reference to the <code>SmartString</code> wrapped by …\nGet a mutable reference to the value of an entry in the …\nReturns a mutable reference into the given <code>Arc</code>, without …\nGet the value of this expression if it is a variable name …\nGet a sub-module in the <code>Module</code>.\nGet the value of an entry in the <code>Scope</code>, starting from the …\nGet a mutable reference the value of an entry in the <code>Scope</code>…\nGet a reference the value of an entry in the <code>Scope</code>, …\nGet a <code>Module</code> variable as a <code>Dynamic</code>.\nGet the value of a <code>Module</code> variable.\nIf this expression is a variable name, return it.  …\nGreater-than comparison for two <code>Arc</code>s.\nIs there a <code>NativeCallContext</code> parameter for this function?\nHash the <code>Dynamic</code> value.\nGet the ID of the <code>Module</code>, if any.\nSet the function to the global namespace.\nSet the function to the internal namespace.\nIncrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nIncrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the <code>Dynamic</code> into an <code>Array</code>.\nConvert the <code>Dynamic</code> into a <code>Blob</code>.\nConvert a <code>LexError</code> into a <code>ParseError</code>.\nConvert the <code>Dynamic</code> into an <code>ImmutableString</code>.\nReturns the inner value, if the <code>Arc</code> has exactly one strong …\nConsumes this <code>RwLock</code>, returning the underlying data.\nConsume the <code>ImmutableString</code> and convert it into a <code>String</code>.\nConsumes the <code>Arc</code>, returning the wrapped pointer.\nConsumes the <code>Arc</code>, returning the wrapped pointer and …\nMake this <code>Dynamic</code> read-only (i.e. a constant).\nConvert this function into a <code>RhaiFunc</code>.\nConvert the <code>Dynamic</code> into a <code>String</code>.\nConvert the <code>Dynamic</code> into a <code>Vec</code>.\nIs the value held by this <code>Dynamic</code> a particular type?\nReturn <code>true</code> if the <code>Dynamic</code> holds an <code>Array</code>.\nIs this <code>Position</code> at the beginning of a line?\nReturn <code>true</code> if the <code>Dynamic</code> holds a <code>Blob</code>.\nReturn <code>true</code> if the <code>Dynamic</code> holds a <code>bool</code>.\nCan this error be caught?\nReturn <code>true</code> if the <code>Dynamic</code> holds a <code>char</code>.\n<code>true</code> if the statement is <code>const</code>, otherwise it is <code>let</code>.\n<code>true</code> if the statement is <code>const</code>, otherwise it is <code>let</code>.\nCheck if the named entry in the <code>Scope</code> is constant.\nIs the function pointer curried?\nReturns <code>true</code> if this <code>Module</code> contains no items.\nReturns <code>true</code> if this <code>Scope</code> contains no variables.\nReturn <code>true</code> if the <code>Dynamic</code> holds a <code>FnPtr</code>.\n<code>true</code> if the variable is declared at global level (i.e. …\nIs this a global namespace?\nIs the <code>Module</code> indexed?\nReturn <code>true</code> if the <code>Dynamic</code> holds the system integer type …\nIs the <code>Module</code> an internal Rhai system module?\nRegister a type iterator. This is an advanced API.\nReturn <code>true</code> if the <code>Dynamic</code> holds a <code>Map</code>.\nIs this a module namespace?\nIs there no <code>Position</code>?\nDetermines whether the lock is poisoned.\nIs this a pseudo error?  A pseudo error is one that does …\nIs this <code>Dynamic</code> read-only?\nIs the <code>Module</code> a Rhai standard library module?\nReturn <code>true</code> if the <code>Dynamic</code> holds an <code>ImmutableString</code>.\nIs this error a system exception?\nReturn <code>true</code> if the <code>Dynamic</code> holds a timestamp.\nReturn <code>true</code> if the <code>Dynamic</code> holds a <code>()</code>.\nDoes this <code>Dynamic</code> hold a variant data type instead of one …\nGet an iterator to entries in the <code>Scope</code>. Shared values are …\nIterate the curried arguments.\nMutably-iterate the curried arguments.\nExtract all top-level literal constant and/or variable …\nGet an iterator to entries in the <code>Scope</code>. Shared values are …\nGet an iterator to the sub-modules in the <code>Module</code>.\nGet an iterator to the variables in the <code>Module</code>.\n‘Less than or equal to’ comparison for two <code>Arc</code>s.\nGet the number of entries inside the <code>Scope</code>.\nGet the line number (1-based), or <code>None</code> if there is no …\nLess-than comparison for two <code>Arc</code>s.\nMakes a mutable reference into the given <code>Arc</code>.\nMake sure that the <code>ImmutableString</code> is unique (i.e. no …\nMerge two <code>AST</code> into one.  Both <code>AST</code>’s are untouched and a …\nMerge another <code>Module</code> into this <code>Module</code>.\nName of the variable to be declared.\nName of the variable to be declared.\nInequality for two <code>Arc</code>s.\nThe current nesting level, with zero being the global …\nThe current nesting level, with zero being the global …\nCreate a new <code>NativeCallContext</code>.\nConstructs a new <code>Arc&lt;T&gt;</code>.\nCreates a new instance of an <code>RwLock&lt;T&gt;</code> which is unlocked.\nCreate a new <code>FuncRegistration</code>.\nCreate a new <code>Module</code>.\nCreate a new function pointer.\nCreate a new <code>ImmutableString</code>.\nCreate a new <code>Position</code>.\nCreate a new <code>Scope</code>.\nCreate a new <code>Position</code>.\nConstructs a new <code>Arc&lt;T&gt;</code> while giving you a <code>Weak&lt;T&gt;</code> to the …\nCreate a new <code>FuncRegistration</code> for a property getter.\nConstructs a new <code>Arc&lt;T&gt;</code> in the provided allocator.\nCreate a new <code>FuncRegistration</code> for an index getter.\nCreate a new <code>FuncRegistration</code> for an index setter.\nCreate a new <code>FuncRegistration</code> for a property setter.\nConstructs a new <code>Arc</code> with uninitialized contents.\nConstructs a new <code>Arc</code> with uninitialized contents in the …\nConstructs a new atomically reference-counted slice with …\nConstructs a new atomically reference-counted slice with …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new atomically reference-counted slice with …\nConstructs a new atomically reference-counted slice with …\nReturns an instant corresponding to “now”.\nGet the number of curried arguments.\nGet the number of parameters for this function.\nDebug-print this custom type.\nPretty-print this custom type.\nReturns an fallback <code>Position</code> if it is <code>NONE</code>?\nModule containing all built-in <em>packages</em> available to Rhai, …\nGet the type ID’s of this function’s parameters.\nParse function call arguments into a container.\nPartial comparison for two <code>Arc</code>s.\nConstructs a new <code>Pin&lt;Arc&lt;T&gt;&gt;</code>. If <code>T</code> does not implement <code>Unpin</code>…\nConstructs a new <code>Pin&lt;Arc&lt;T, A&gt;&gt;</code> in the provided allocator. …\nModule defining macros for developing <em>plugins</em>.\nRemove the last entry from the <code>Scope</code>.\nGet the position of this expression.\nPosition of the function call.\nGet the position of this error.\nGet the position of this parse error.\nGet the character position (1-based), or <code>None</code> if at …\nReturns <code>true</code> if the two <code>Arc</code>s point to the same allocation …\nReturns <code>true</code> if the two <code>ImmutableString</code>’s point to the …\nAdd (push) a new entry to the <code>Scope</code>.\nAdd (push) a new constant to the <code>Scope</code>.\nAdd (push) a new constant with a <code>Dynamic</code> value to the …\nAdd (push) a new <code>Dynamic</code> entry to the <code>Scope</code>.\nLocks this <code>RwLock</code> with shared read access, blocking the …\nGet a reference of a specific type to the <code>Dynamic</code>.\nMacro to register a <em>plugin function</em> (defined via …\nRegister the function into the specified <code>Engine</code>.\nRemove the last entry in the <code>Scope</code> by the specified name …\nTruncate (rewind) the <code>Scope</code> to a previous size.\nEvaluate a string as a script.\nEvaluate a file.\nReturns the amount of time elapsed from another instant to …\nThe current <code>Scope</code>.\nGet a mutable reference to the current <code>Scope</code>.\n<em>(serde)</em> Serialization and deserialization support for <code>serde</code>…\nSet curried arguments to the function pointer.\nMap a custom type to a friendly display name.\nMap a custom type to a friendly display name.\nMacro to register a <em>plugin function</em> into a Rhai <code>Module</code>.\nMacro to register a <em>plugin function</em> into a Rhai <code>Module</code> and …\nSet a native Rust function into the <code>Module</code>, returning a <code>u64</code>…\nSet a native Rust function into the <code>Module</code> based on a …\nSet a Rust getter function taking one mutable parameter, …\nSet a pair of Rust getter and setter functions into the …\nSet the ID of the <code>Module</code>.\nSet a Rust index getter taking two parameters (the first …\nSet a pair of Rust index getter and setter functions into …\nSet a Rust index setter taking three parameters (the first …\nRegister the function into the specified <code>Module</code>.\nRegister the function into the specified <code>Module</code>.\nSet a type iterator into the <code>Module</code>.\nSet a fallible type iterator into the <code>Module</code>.\nSet a type iterator into the <code>Module</code>.\nSet a fallible type iterator into the <code>Module</code>.\nSet an iterator type into the <code>Module</code> as a type iterator.\nSet a iterator type into the <code>Module</code> as a fallible type …\nSet a native Rust function into the <code>Module</code>, returning a <code>u64</code>…\nUpdate the value of the named entry in the <code>Scope</code> if it …\nOverride the position of this error.\nSet a Rust setter function taking two parameters (the …\nSet the source.\nSet a sub-module into the <code>Module</code>.\nAttach arbitrary data to this <code>Dynamic</code>.\nUpdate the value of the named entry in the <code>Scope</code>.\nSet a variable into the <code>Module</code>.\nThe current source.\nGet the source, if any.\nThe current source.\nGets the number of strong (<code>Arc</code>) pointers to this …\nStrong count of references to the underlying string.\nReturns the amount of time elapsed from another instant to …\nCustom state kept in a <code>Dynamic</code>.\nGet the arbitrary data attached to this <code>Dynamic</code>.\nCustom state kept in a <code>Dynamic</code>.\nMutable reference to the custom state kept in a <code>Dynamic</code>.\nReturn this <code>Dynamic</code>, replacing it with <code>Dynamic::UNIT</code>.\nRemove the position information from this error and return …\nThe current bound <code>this</code> pointer, if any.\nMutable reference to the current bound <code>this</code> pointer, if …\nConvert the <code>Dynamic</code> value into specific type.\nConvert the <code>Dynamic</code> value into specific type.\nConstructs a new <code>Arc&lt;T&gt;</code>, returning an error if allocation …\nConstructs a new <code>Arc&lt;T, A&gt;</code> in the provided allocator, …\nConstructs a new <code>Arc</code> with uninitialized contents, …\nConstructs a new <code>Arc</code> with uninitialized contents, in the …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new <code>Pin&lt;Arc&lt;T&gt;&gt;</code>, return an error if …\nConstructs a new <code>Pin&lt;Arc&lt;T, A&gt;&gt;</code> in the provided allocator, …\nAttempts to acquire this <code>RwLock</code> with shared read access.\nReturns the inner value, if the <code>Arc</code> has exactly one strong …\nAttempts to lock this <code>RwLock</code> with exclusive write access.\nGet the <code>TypeId</code> of the value held by this <code>Dynamic</code>.\nGet the name of the type of the value held by this <code>Dynamic</code>.\nUnwrap this error and get the very base error.\nIf we have the only reference to <code>T</code> then unwrap it. …\nUpdate the namespace of a registered function.\nGets the number of <code>Weak</code> pointers to this allocation.\nWill the variable <em>shadow</em> an existing variable?\nWill the variable <em>shadow</em> an existing variable?\nCreate a new <code>Module</code> with a pre-sized capacity for …\nCreate a new <code>Scope</code> with a particular capacity.\nRegister a custom method.\nRegister a getter function.\nRegister a fallible getter function.\nShort-hand for registering both getter and setter …\nRegister an index getter.\nRegister an fallible index getter.\nShort-hand for registering both index getter and setter …\nRegister an index setter.\nRegister an fallible index setter.\nSet a pretty-print name for the <code>type_of</code> function.\nSet the namespace of the function.\nSet whether the function is <em>pure</em>. A pure function has no …\nRegister a custom fallible function.\nRegister a setter function.\nRegister a fallible setter function.\nSet whether the function is <em>volatile</em>. A volatile function …\nLocks this <code>RwLock</code> with exclusive write access, blocking …\nGet a mutable reference of a specific type to the <code>Dynamic</code>.\nFixed hashing seeds for stable hashing.\nGet the current hashing Seed.\nGet the current hashing Seed.\nSet the hashing seed. This is used to hash functions etc.\nSet the hashing seed. This is used to hash functions etc.\nBasic arithmetic package.\nPackage of basic array utilities.\nPackage of basic BLOB utilities.\nPackage of basic function pointer utilities.\nPackage of basic range iterators\nPackage of basic object map utilities.\nBasic mathematical package.\nPackage of basic string utilities (e.g. printing)\nPackage of basic timing utilities.\nPackage of basic bit-field utilities.\nCore package containing basic facilities.\nPackage of core language features.\nPackage of basic logic operators.\nPackage of additional string utilities over …\nTrait that all packages must implement.\nStandard package containing all built-in features.\nGet a reference to a shared module from this package.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitialize the package. Functions should be registered …\nInitialize the package with an <code>Engine</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>ArithmeticPackage</code>\nCreate a new <code>BasicArrayPackage</code>\nCreate a new <code>BitFieldPackage</code>\nCreate a new <code>BasicBlobPackage</code>\nCreate a new <code>BasicFnPackage</code>\nCreate a new <code>BasicIteratorPackage</code>\nCreate a new <code>LanguageCorePackage</code>\nCreate a new <code>LogicPackage</code>\nCreate a new <code>BasicMapPackage</code>\nCreate a new <code>BasicMathPackage</code>\nCreate a new <code>CorePackage</code>\nCreate a new <code>StandardPackage</code>\nCreate a new <code>BasicStringPackage</code>\nCreate a new <code>MoreStringPackage</code>\nCreate a new <code>BasicTimePackage</code>\nRegister the package with an <code>Engine</code>.\nMacro to implement the [<code>CustomType</code>][rhai::CustomType] …\nDynamic type containing any value.\nRhai main scripting engine.\nContains the error value\nArithmetic error encountered. Wrapped value is the error …\nArray access out-of-bounds. Wrapped values are the current …\nAssignment to a constant variable. Wrapped value is the …\nBit-field indexing out-of-bounds. Wrapped values are the …\nError encountered for a custom syntax. Wrapped values are …\nData race detected when accessing a variable. Wrapped …\nData value over maximum size limit. Wrapped value is the …\nInappropriate property access. Wrapped value is the …\nThe <code>for</code> statement encounters a type that is not iterable.\nForbidden variable name. Wrapped value is the variable …\nCall to an unknown function. Wrapped value is the function …\nAn error has occurred inside a called function. Wrapped …\nAn error has occurred while loading a module. Wrapped …\nAccess of an invalid index. Wrapped value is the index …\nTrying to index into a type that has no indexer function …\nData is not of the required type. Wrapped values are the …\nReturned type is not the same as the required output type. …\nUsage of an unknown module. Wrapped value is the module …\nCalling a non-pure method on a constant.  Wrapped value is …\nSyntax error.\nAccess of an unknown object map property. Wrapped value is …\nRun-time error encountered. Wrapped value is the error …\nCall stack over maximum limit.\nString indexing out-of-bounds. Wrapped values are the …\nSystem error. Wrapped values are the error message and the …\nThe script is prematurely terminated. Wrapped value is the …\nModules over maximum limit.\nNumber of operations over maximum limit.\nNumber of variables over maximum limit.\nAccess to <code>this</code> that is not bound.\nShadowing of an existing variable disallowed. Wrapped …\nAccess of an unknown variable. Wrapped value is the …\nEvaluation result.\nNot an error: Value returned from a script via the <code>exit</code> …\nA type representing the access mode of a function.\nA type representing the namespace of a function.\nType for fine-tuned module function registration.\nExpose to global namespace.\nThe system immutable string type.\nModule namespace only.\nAn iterator function.\nBreaking out of loops - not an error if within a loop. The …\nA native Rust object method with the first argument passed …\nA module which may contain variables, sub-modules, …\nContext of a native Rust function call.\nContains the success value\nA plugin function,\nTrait implemented by a <em>plugin function</em>.\nA location (line number + character position) in the input …\nPrivate function.\nPublic function.\nA pure native Rust function with all arguments passed by …\nAn empty raw <code>Engine</code>.\nNot an error: Value returned from a script via the <code>return</code> …\n<em>(internals)</em> A type encapsulating a function callable by …\nResult of a Rhai function.\nA <code>TypeId</code> represents a globally unique identifier for a …\nGet the access mode.\nIs <code>if</code>-expression allowed? Default is <code>true</code>.\nAre loop expressions allowed? Default is <code>true</code>.\nIs looping allowed? Default is <code>true</code>.\nIs variables shadowing allowed? Default is <code>true</code>.\nIs statement-expression allowed? Default is <code>true</code>.\nIs <code>switch</code> expression allowed? Default is <code>true</code>.\nBuild the API of a custom type for use with the <code>Engine</code>.\nCall the plugin function with the arguments provided.\nMacro to combine a <em>plugin module</em> into an existing module.\nCompact a script to eliminate insignificant whitespaces …\nCompile a string into an <code>AST</code>, which can be used later for …\nCompile a string containing an expression into an <code>AST</code>, …\nCompile a string containing an expression into an <code>AST</code> …\nCompile a script file into an <code>AST</code>, which can be used later …\nCompile a script file into an <code>AST</code> using own scope, which …\nWhen passed a list of strings, first join the strings into …\nCompile a string into an <code>AST</code> using own scope, which can be …\nGet an empty <code>ImmutableString</code> which refers to a shared …\nEvaluate a string, but throw away the result and only …\nEvaluate an <code>AST</code>, but throw away the result and only return …\nEvaluate an <code>AST</code> with own scope, but throw away the result …\nEvaluate a file, but throw away the result and only return …\nEvaluate a file with own scope, but throw away the result …\nEvaluate a string with own scope, but throw away the …\nGet the default value of the custom state for each …\nGet a mutable reference to the default value of the custom …\nDisable a particular keyword or operator in the language.\nEvaluate a string as a script, returning the result value …\nEvaluate an <code>AST</code>, returning the result value or an error.\nEvaluate an <code>AST</code> with own scope, returning the result value …\nEvaluate a string containing an expression, returning the …\nEvaluate a string containing an expression with own scope, …\nEvaluate a script file, returning the result value or an …\nEvaluate a script file with own scope, returning the …\nEvaluate a string as a script with own scope, returning …\nAttribute, when put on a Rust function, turns it into a …\nAttribute, when put on a Rust module, turns it into a …\nMacro to generate a Rhai <code>Module</code> from a <em>plugin module</em> …\nMacro to automatically expose a Rust function, type-def or …\nRaise error if an object map property does not exist? …\nIs fast operators mode enabled? Default is <code>false</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a reference to the shared encapsulated environment of …\nGet an interned string.\nGet a reference to an iterator function.\nGet a shared reference to a native Rust function.\nGet a shared reference to a plugin function.\nDoes this plugin function contain a <code>NativeCallContext</code> …\nIs there a <code>NativeCallContext</code> parameter?\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this an iterator function?\nIs this a native Rust method function?\nIs this plugin function a method?\nIs this a native Rust function?\nIs this a plugin function?\nIs this function private?\nIs this function public?\nIs this plugin function pure?\nIs this a pure native Rust function?\nIs this a script-defined function?\nIs a particular keyword or operator disabled?\nIs this plugin function volatile?\nIs this function volatile?\nPretty-print a type name.\nThe maximum number of strings to be interned.\nBasic functions for dealing with memory.\nCreate a new <code>Engine</code>.\nCreate a new <code>Engine</code> with minimal built-in functions. It …\nReturns the <code>TypeId</code> of the type this generic function has …\nOverride default action of <code>debug</code> (print to stdout using …\nProvide a callback that will be invoked before the …\nOverride default action of <code>print</code> (print to stdout using …\nProvide a callback that will be invoked before each …\nParse a JSON string into an object map.\nRegister a custom operator with a precedence into the …\nRegister a custom syntax with the <code>Engine</code>.\nRegister a custom syntax with the <code>Engine</code>.\nRegister a custom syntax with the <code>Engine</code> with custom …\nMacro to register a <em>plugin function</em> (defined via …\nRegister a custom function with the <code>Engine</code>.\nRegister a getter function for a member of a registered …\nRegister a getter function for a member of a registered …\nShort-hand for registering both getter and setter functions\nRegister a shared <code>Module</code> into the global namespace of …\nRegister an index getter for a custom type with the <code>Engine</code>.\nRegister an index getter for a custom type with the <code>Engine</code>.\nShort-hand for registering both index getter and setter …\nRegister an index setter for a custom type with the <code>Engine</code>.\nRegister an index setter for a custom type with the <code>Engine</code>.\nRegister a type iterator for an iterable type with the …\nRegister a fallible type iterator for an iterable type …\nRegister a function of the <code>Engine</code>.\nRegister a custom fallible function with the <code>Engine</code>.\nRegister a setter function for a member of a registered …\nRegister a setter function for a member of a registered …\nRegister a custom type for use with the <code>Engine</code>. The type …\nRegister a custom type for use with the <code>Engine</code>, with a …\nRegister a custom type for use with the <code>Engine</code>, with a …\nEvaluate a string as a script.\nEvaluate an <code>AST</code>.\nEvaluate an <code>AST</code> with own scope.\nEvaluate a file.\nEvaluate a file with own scope.\nEvaluate a string as a script with own scope.\nSet whether <code>if</code>-expression is allowed.\nSet whether loop expressions are allowed.\nSet whether looping is allowed.\nSet whether variables shadowing is allowed.\nSet whether statement-expression is allowed.\nSet whether <code>switch</code> expression is allowed.\nSet the default value of the custom state for each …\nMacro to register a <em>plugin function</em> into a Rhai <code>Module</code>.\nMacro to register a <em>plugin function</em> into a Rhai <code>Module</code> and …\nSet whether to raise error if an object map property does …\nSet whether fast operators mode is enabled.\nSet the maximum number of strings to be interned.\nSet whether strict variables mode is enabled.\nIs strict variables mode enabled? Default is <code>false</code>.\nShared function pointer.\nShared function pointer.\nShared function pointer.\nShared function pointer.\nDoes the function take a <code>NativeCallContext</code> parameter?\nDoes the function take a <code>NativeCallContext</code> parameter?\nThis is a dummy field and is not used.\nAllow operating on constants?\nIs this function volatile?\nIs this function volatile?\nAssume only that alignment conditions are met.\nWhat transmutation safety conditions shall the compiler …\nAre values of a type transmutable into values of another …\nOpaque type representing the discriminant of an enum.\nAssume only that lifetime conditions are met.\nA wrapper to inhibit the compiler from automatically …\nA wrapper type to construct uninitialized instances of <code>T</code>.\nDo not assume that <em>you</em> have ensured any safety properties …\nAssume only that safety conditions are met.\nAssume only that dynamically-satisfiable validity …\nReturns the ABI-required minimum alignment of a type in …\nReturns the ABI-required minimum alignment of the type of …\nReturns the ABI-required minimum alignment of the type of …\nWhen <code>true</code>, the compiler assumes that <em>you</em> are ensuring …\nAssume both <code>self</code> and <code>other_assumptions</code>.\nExtracts the values from an array of <code>MaybeUninit</code> …\nReturns the contents of this <code>MaybeUninit</code> as a slice of …\nReturns the contents of this <code>MaybeUninit</code> as a mutable …\nGets a mutable pointer to the contained value. Reading …\nGets a pointer to the contained value. Reading from this …\nExtracts the value from the <code>MaybeUninit&lt;T&gt;</code> container. This …\nDrops the contained value in place.\nGets a mutable (unique) reference to the contained value.\nReads the value from the <code>MaybeUninit&lt;T&gt;</code> container. The …\nGets a shared reference to the contained value.\nAssume <code>self</code>, excepting <code>other_assumptions</code>.\nClones the elements from <code>src</code> to <code>this</code>, returning a mutable …\nBitwise-copies a value.\nCopies the elements from <code>src</code> to <code>this</code>, returning a mutable …\nReturns a value uniquely identifying the enum variant in <code>v</code>.\nDisposes of a value.\nManually drops the contained value. This is exactly …\nFills <code>this</code> with elements by cloning <code>value</code>, returning a …\nFills <code>this</code> with elements yielded by an iterator until …\nFills <code>this</code> with elements returned by calling a closure …\nTakes ownership and “forgets” about the value <strong>without </strong>…\nLike <code>forget</code>, but also accepts unsized values.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExtracts the value from the <code>ManuallyDrop</code> container.\nWhen <code>true</code>, the compiler assume that <em>you</em> are ensuring that …\nReturns the ABI-required minimum alignment of a type in …\nReturns the ABI-required minimum alignment of the type of …\nReturns <code>true</code> if dropping values of type <code>T</code> matters.\nWrap a value to be manually dropped.\nCreates a new <code>MaybeUninit&lt;T&gt;</code> initialized with the given …\nExpands to the offset in bytes of a field from the …\nMoves <code>src</code> into the referenced <code>dest</code>, returning the previous …\nWhen <code>true</code>, the compiler assumes that <em>you</em> have ensured that …\nReturns the size of a type in bytes.\nReturns the size of the pointed-to value in bytes.\nReturns the size of the pointed-to value in bytes.\nReturns the contents of this slice of <code>MaybeUninit</code> as a …\nReturns the contents of this mutable slice of <code>MaybeUninit</code> …\nGets a mutable pointer to the first element of the array.\nGets a pointer to the first element of the array.\nAssuming all the elements are initialized, get a mutable …\nAssuming all the elements are initialized, get a slice to …\nSwaps the values at two mutable locations, without …\nReplaces <code>dest</code> with the default value of <code>T</code>, returning the …\nTakes the value from the <code>ManuallyDrop&lt;T&gt;</code> container out.\nReinterprets the bits of a value of one type as another …\nInterprets <code>src</code> as having type <code>&amp;Dst</code>, and then reads <code>src</code> …\nTransposes a <code>MaybeUninit&lt;[T; N]&gt;</code> into a <code>[MaybeUninit&lt;T&gt;; N]</code>…\nCreates a new <code>MaybeUninit&lt;T&gt;</code> in an uninitialized state.\nCreate a new array of <code>MaybeUninit&lt;T&gt;</code> items, in an …\nBypasses Rust’s normal memory-initialization checks by …\nWhen <code>true</code>, the compiler assumes that <em>you</em> are ensuring that …\nReturns the number of variants in the enum type <code>T</code>.\nSets the value of the <code>MaybeUninit&lt;T&gt;</code>.\nReturns the value of type <code>T</code> represented by the all-zero …\nCreates a new <code>MaybeUninit&lt;T&gt;</code> in an uninitialized state, …\nDeserializer for <code>Dynamic</code>.\nSerializer for <code>Dynamic</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDeserialize a <code>Dynamic</code> value into a Rust type that …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a <code>DynamicDeserializer</code> from a reference to a <code>Dynamic</code> …\nCreate a <code>DynamicSerializer</code> from a <code>Dynamic</code> value.\nSerialize a Rust type that implements <code>serde::Serialize</code> …")